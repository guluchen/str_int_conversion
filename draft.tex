\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}

\usepackage{fancyvrb}
\usepackage{xcolor}
\usepackage{amssymb} 
\usepackage{tikz}
\usepackage[autostyle]{csquotes}
\usepackage{listings}
\usepackage{multirow}
\synctex=1

\usetikzlibrary{positioning}
\usetikzlibrary{arrows,automata}

\title{Handling String-Number Conversion in String Constraint Solving}
\author{}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\hide}[1]{}
\newcommand{\tool}{{\textsf{Z3-pfa}}}

\newcommand{\nat}{\mathbb{N}}
\newcommand{\todo}[1]{{\color{blue}TODO: #1}}
\newcommand{\lh}[1]{{\color{orange}Lukas: #1}}
\newcommand{\yfc}[1]{{\color{blue}YFC: #1}}
\newcommand{\petr}[1]{{\color{pink}Petr: #1}}
\newcommand{\sti}[1]{\mbox{\textsf{toInt}($#1$)}}
\newcommand{\its}[1]{\mbox{\textsf{toStr}($#1$)}}
\newcommand{\varn}{\mbox{$\mathbb{V}_{\mathbb{Z}}$}}
\newcommand{\vars}{\mbox{$\mathbb{V}_{\Sigma^*}$}}
\newcommand{\cvars}{\mbox{$\mathbb{V}_{\Sigma_\epsilon}$}}
\newcommand{\pvars}{\mbox{$\mathbb{V}_{\sharp}$}}
%\newcommand{\cvar}{\mbox{$V_{\Sigma_\epsilon}$}}
%\newcommand{\cvarone}{\mbox{$V_{\Sigma_\epsilon}$}}
%\newcommand{\cvartwo}{\mbox{$V'_{\Sigma_\epsilon}$}}
\newcommand{\cvarone}{V}
\newcommand{\cvartwo}{V'}
\newcommand{\cvar}{V}
\newcommand{\modelsof}[1]{[\![#1]\!]}
\newcommand{\true}{\mbox{$\mathsf{true}$}}
\newcommand{\false}{\mbox{$\mathsf{false}$}}
\newcommand{\enc}[1]{[\![#1]\!]}
%\newcommand{\parikhof}[1]{\mathit{Parikh}{(#1)}}
\newcommand{\parikhof}[1]{\mathbb{P}{(#1)}}
\newcommand{\parikhwof}[2]{|#1|_{#2}}
%\newcommand{\semof}[1]{||#1||}
\newcommand{\semof}[1]{\modelsof{#1}}
\newcommand{\decode}[1]{\mathit{decode_{#1}}}
%\newcommand{\parikhfof}[1]{\Phi_{\parikhof{#1}}}
\newcommand{\parikhfof}[1]{\Phi_{\mathbb{P}}(#1)} %shouldn't it be something that takes automaton as parameter and returns formula?
\newcommand{\pim}{I_{\#}}
%\newcommand{\syncop}{\Cap}
\newcommand{\syncop}{\times}
\newcommand{\syncof}[2]{#1 \syncop #2}
\newcommand{\syncfof}[2]{\Psi_{\syncof {#1} {#2}}}
\newcommand{\syncT}{T_\syncop}
\newcommand{\pvarsof}[1]{\#{#1}}
\newcommand{\pvar}{\pvarsof V}
\newcommand{\pvarone}{\pvarsof V}
\newcommand{\pvartwo}{\pvarsof {V'}}
\newcommand{\defeq}{::=}

\maketitle


\lstdefinelanguage{JavaScript}{
	keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
	keywordstyle=\color{blue}\bfseries,
	ndkeywords={class, export, boolean, throw, implements, import, this},
	ndkeywordstyle=\color{darkgray}\bfseries,
	identifierstyle=\color{black},
	sensitive=false,
	comment=[l]{//},
	morecomment=[s]{/*}{*/},
	commentstyle=\color{purple}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	morestring=[b]',
	morestring=[b]"
}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction} \label{section:introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



String constraint solving has received considerable attention in the constraint solving community, with solvers such as CVC4 and Z3 implementing solvers of ever-increasing sophistication.  Operations such as substring and string length are widely supported, and recent solvers such as Z3-str3 have shown impressive results.  However, these solvers have limited for operations that convert between strings and integers; string length operations are sometimes well supported, but not parsing a string as an integer or turning an integer value into its string form.  When there is support, it is often limited to ground terms, i.e. at least one side of the conversion must be a constant.  Thus, $n = \sti{x}$ or $x = \its{5}$ are handled but $n = \sti{x}$ will fail.

As solvers such Z3 are applied to symbolic execution of programming languages, this is increasingly becoming a severe limitation.  For many languages such as Java, conversion between integers and strings is a niche operation, and much symbolic execution can be done without supporting it; however, this is not true of some scripting languages, of which JavaScript is the most notable.  JavaScript is a key language---it powers most interactive content on the Web, and increasingly server-side code with nodejs---and it has conversions between strings and integers embedded in the core of its semantics.

\begin{verbatim}
function resetArray(arr) {
  for(var i = 0; i < arr.length; i++) {
    arr[i] = 0
  }
}
\end{verbatim}



A casual glance at the above code reveal no use of strings at all, but the semantics of field access is somewhat unusual in JavaScript: all array indices act like strings, and numeric indices are converted to strings.  Any faithful symbolic execution of JavaScript must handle such conversions for even basic array operations to work correctly; consider the following code snippet that uses {\tt{resetArray}}, with the value of {\tt{x}} shown on the right:

\begin{tabular}{l|c}
	{\tt{x = [0, 1, 2, 3, 4, 5]}} & [0, 1, 2, 3, 4, 5] \\
	{\tt{resetArray(x)}} & [0, 0, 0, 0, 0, 0] \\
	{\tt{x[3] = 5}} & [0, 0, 0, 5, 0, 0] \\
	{\tt{x["12"] = 7}} & [0, 0, 0, 5, 0, 0, , , , , , 7] \\
	{\tt{resetArray(x)}} & [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] \\
\end{tabular}

In this code, string and integer values access the same array elements interchangeably, necessitating conversions between string and integers to faithfully model JavaScript semantics.  This conversion is mandated explicitly by JavaScript semantics: the 2019 edition of ECMAScript requires that $ToPropertyKey$ be called on the element expression (\S{12.3.2.1}), and $ToPropertyKey$ calls {\tt{ToString}} on that value in all but special cases (\S{7.1.14}). On the other hand, the size of an array ({\tt{arr.length}} in the example) is defined as the ``largest integer index plus one'', so the integer value of element expression can affect the array size.

Now observe that {\tt{resetArray}} assigns to the array in a loop of which the size cannot, in general, be known a priori; as such, falls into the case where neither the string nor the integer in a conversion is constant and hence most SMT solvers will not be able to handle it. More specifically, in some program the assignment {\tt{x[k] = 5}} can happen before calling {\tt{resetArray(x)}}, where {\tt{k}} is an user input string. One would need to know the value of $\sti{k}$ and hence whether it will affect the size of the array {\tt{x}}. This is a rather straightforward array operation, and so this limit will cripple any model of non-trivial JavaScript code. 

For the purpose of program analysis, string solver also needs to support \emph{equality constraints} (e.g. $x.y = y.x$), \emph{regular constraints} (e.g., $x \in (a.b)^*$), and \emph{integer constraints} (e.g., $|x|-|y|>3$). Most of the standard string operations can be encoded using the above three types of constraints. For instance, $y=x.charAt(i)$ can be encoded as $x=x_1.x_2.x_3 \wedge |x_1| = i \wedge |x_2| =1 \wedge y= x_2$. Those are also the type of constraints supported by most state-of-the-art string constraint solvers such as Z3, CVC4, Z3Str3, and Trau+.

\yfc{I am not sure how to add other examples here in a nice way, one reason is we are very specifically focused on Javascript, but other examples, e.g., the credit card one, is very general.}

\hide{
Indeed, the analysis of string manipulating program is becoming more and more important nowadays. Various infamous security vulnerabilities such as injection and cross-site scripting attack are caused by malicious string input values. In the past, a significant amount of research efforts have been investigated to symbolic execution and test case generation of string manipulating programs~\cite{saxena2010symbolic,artzi2011framework,huang2004securing,sen2013jalangi} and string constraint solving~\cite{kiezun2009hampi,abdulla2014string,zheng2013z3,abdulla2015norn,abdulla2017flatten,wang2016string,abdulla2018trau,chen2019decision,zheng2017z3str2} is the core enabling technology. }





\hide{Why this problem is important? Need to say it is used often, e.g., read 
from text file or user input. Why this problem is challenging? It is undecidable. Some tricky cases 
using string as array index. Bounded SAT-based encoding might not work even for 
very simple constraints. e.g., $y=str2int(x) \wedge y>9999999$, if $x$ is a 
ASCII string, then XXX Boolean variables are required. Or we can just propose 
an example that all major solver fails. Maybe we still say our approach is still over-approximation + under-approximation, in this case, need to think how to present the over-approximation part. Maybe no CEGAR is fine.

String data type is omnipresent in modern programming languages. Various infamous security vulnerabilities such as injection and cross-site scripting attack are caused by malicious string values. As a results, in the past, a significant amount of research efforts have been investigated to symbolic execution and test case generation of string manipulating programs~\cite{saxena2010symbolic,artzi2011framework,huang2004securing,sen2013jalangi}. The core enabling technology for these approaches is string constraint solving~\cite{kiezun2009hampi,abdulla2014string,zheng2013z3,abdulla2015norn,abdulla2017flatten,wang2016string,abdulla2018trau,chen2019decision,zheng2017z3str2}. However, all these modern solvers fall short when \textit{string-number conversion function} occurs in the program.


String-number conversion function is very frequently used in string-manipulating programs. For example, often that programs read plain string input from text files, partition it according to some predefined separator symbol (e.g., the comma symbol), and then convert each string partition to the desired data type (often integers). In the reverse direction, programs also convert values in numerical data type back to string and store them as text files. 

Incorrect handling of string-number conversion can cause very subtle bugs.
For example, in JavaScript, variables are untyped and (implicit) type conversion happens automatically to the stored values. Consider the following simple program


\begin{lstlisting}[breaklines=true,language=JavaScript]
var arr = [1,...,M];
var input = //from user
if(0<=input<M-1){
	document.write(arr[input])
}
\end{lstlisting}

The program reads input value from users and use it as the array index. This program works perfectly no matter the input is in string form (e.g., ``1'', ``3'') or numerical form (e.g., $1$, $3$). Both of them can pass though the range test (when the input is a string, it will be first convert to integer and then compared with $0$ and $M$). However, the programmer may find later that he wants to shift the index value by one, say, change \texttt{document.write(arr[input])} to \texttt{document.write(arr[input+1])}. In such case, the program is still correct if \texttt{input} is a number, but will behave incorrectly if \texttt{input} is a string. For example, when \texttt{input=="5"}, the \texttt{+} operator in \texttt{input+1} will be interpreted as string concatenation and the value $1$ will be converted to a string. Therefore, the program will output \texttt{arr["51"]} instead of \texttt{arr["6"]}. If one searches CVE (Common Vulnerabilities and Exposures), he/she can find a number of vulnerabilities (e.g., clauses array-out-of-bound) due to incorrect handling of string-number conversion.

In the example above, we can detect the array-out-of-bound problem (that happens when \texttt{input} is a string) by checking the satisfiability of the string constraint below\footnote{The case \texttt{input} stores a integer value can be check by another formula.}. 

$$
\begin{array}{c}
0 \leq \sti{input}<M-1 \wedge \\
\neg(index = input\cdot \its{1} \wedge 0 \leq \sti{index} <M-1)
\end{array}
$$


Such constraint contains \textit{string-number conversion} functions (e.g., $\sti{input}$ and $\sti{index}$), \textit{equality constraints} (e.g., $index = input\cdot \its{1}$), and \textit{integer constraints} (e.g., $0 \leq \sti{input}<M$). }

Solving string constraint with string-number conversion is a very challenging problem. From the theoretical point of view, this problem is already proven to be undecidable~\cite{day2018satisfiability}. In practice, in our experiments, all of the state-of-the-art string constraint solvers do not support string-number conversion correctly. Some of them handles such constraints with only over-approximation of the original formula, and is known to have one-side error (see Section~\ref{section:evaluation} for detailed explanation).  \yfc{add concrete evidence}

In this paper, we adopt a framework that handles string constraints with string-number conversion efficiently. Due to the high complexity of solving the problem exactly, our framework uses both over and under-approximation of the string constraints. The over-approximation is for proving UNSAT and the under-approximation is for proving SAT of the string constraint. Both over and under-approximation should fail in a decidable fragment of string constraints that can be efficiently solved. 

For over-approximation, there are a few existing algorithms~\cite{parosh2019chain,z3,chen2019decision}, our framework does not set any restriction on which algorithm to be used. In our experiences, the UNSAT instances in all available benchmarks are not that difficult, and the differences between the major algorithms are very small. In our tool \tool, we use a version that is a simple adaption of the algorithm in~\cite{parosh2019chain}.

The battle field is in fact those SAT instances, for which we develop solutions using under-approximation. For under-approximation, we restrict the search space of each string variable to strings that obey some predefined and parameterized pattern. By adjusting the parameters, one can easily enlarge or prune out the potential solution space. In paper, we propose to use patterns defined by \emph{parametric flat automata} (PFA) (will be defined formally in Section~\ref{section:sfa}). The approach based on PFA is very flexible yet allows very efficiently manipulation. One can pick PFA of \emph{arbitrary structure} for the search space restriction and reduce the string constraint solving problem to a linear formula satisfiability problem in polynomial-time. Moreover, it avoids the \textit{alphabet explosion problem} that the approach in~\cite{abdulla2017flatten} suffers.\yfc{maybe explain a bit somewhere the alphabet explosion problem of PLDI 2017} In contrast to under-approximation based on bit-blasting~\cite{kiezun2009hampi} (i.e., limit the length of the strings and encode the string constraint to a Boolean formula), our linear formula for under-approximation, in general,  still encodes possibility an infinite number of models. Such symbolic encoding based on PFA is the key to handle string-number conversion. In our under-approximation approach, the original undecidable fragment, i.e., string constraint with string-number conversion, is converted to linear formulas and can be solved efficiently in a systematic manner.

More concretely, based on the PFA encoding, we manage to translate the string constraint with string-number function to an equisatisfiable pure numerical constraints. Thus the problem is significantly simplified. We show that if we restrict the variable to arbitrary PFA, one can convert the a string constraint with string-number function to an integer constraint consisting of both polynomials and exponentials. Solving such kind of constraints is a very difficult task. For simpler cases where the variables are real numbers, decision procedures for different subclass polynomial-exponential equations exists~\cite{gan2015decidability,kincaid2019closed,achatz2008deciding}. To the best of our knowledge, the satisfiability problem of polynomial-exponential equations is still open. For efficiency reason, we propose to use PFA with specific structural constraint to handle string-number conversion function. That is, if we encountered a constraint $y=\sti{x}$, then we always restrict the domain of $x$ to some specific kind of PFA, instead of allowing arbitrary PFAs. This allows us to convert a string constraint with string-number conversion function to an equisatisfiable linear formula, which can be solved very efficiently. 

Our string constraint solving produce can be easily integrated in a \emph{satisfiability module theory (SMT)} solver as a theory solver. The integration allows us to express string operations that cannot be reduced to the type of constraints (regular, equality, integer, string-number conversion) supported by our procedure. For example, we can encode \texttt{split} using the code fragment in Figure~\ref{fig:smt_string}. Other functions such as \texttt{replaceAll} and \texttt{reverse} can be encoded in a similar manner. The performance of such encoding might not be as good as those that provide direct support to those operations, but at least it works for some cases in our experiments. Further details of the combination as well as some other implementation details can be found in Section~\ref{section:implementation}.



\begin{figure}
	\begin{Verbatim}[fontsize=\scriptsize,xleftmargin=-4cm]
				(define-fun-rec split ((x String)(y String)(xIdx Int)(aIdx Int)) 
				(Array Int String)
				(ite (= xIdx (str.len x))
				  (store ((as const (Array Int String)) "") aIdx x)
				  (ite (= y (str.at x xIdx)) 
				    (store 
				      (split (str.substr x (+ xIdx 1) (- (str.len x) 1) ) 
				      0 (+ aIdx 1) y) 
				      aIdx
				      (str.substr str 0 xIdx)
				    )
				    (split x (+ xIdx 1) aIdx y)
				  )
				)
			\end{Verbatim}
	 	 				
	 	\caption{Encoding \texttt{Split(x,y)} to an SMTLIB2 formula using recursive functions and the array theory. The recursive function \texttt{split (x y 0 0)} returns an array of type \texttt{(Array Int String)} that maps an index $i$ to the $i$th component (separated by the character $y$ ) of $x$.}
	 	\label{fig:smt_string}
\end{figure}





\todo{Talk about experiments}





\hide{
To ease presentation, in the paper, we only consider string constraints consisting of \emph{equality constraints (a.k.a. word equation)}, \emph{regular constraints}, \emph{length constraints}, and \emph{string-number conversion} functions. 	
	
suggest restricting the string domain to $0^*[0-9]^k$, where $k$ is the maximum 
digit allowed in the corresponding number value. In programming languages 
such  as JavaScript or Python, a number with $k$ digits can be converted from a 
string of length arbitrarily longer than $k$. For example, $12 = 
str2int(``0000012")$. That is why we use $0^*$ at the beginning of the pattern.
Under this domain, we can convert the string-number conversion constraints to 
linear integer constraints, which is much easier to solve. In our experience, 
usually, it suffices to find a solution using a small $k$ for a satisfiable 
constraint. Note that a 64-bit integer number corresponds to a word with 
$k\leq 21$.

Given a formula that is a boolean combination of different types of string constraints, e.g., $\phi=(|x| = |y| \vee \sti{x} = \sti{y})\wedge x = y$, an SMT solver based on the DPLL(T) algorithm~\cite{} treats each string constraint $|x| = |y|$, $\sti{x} = \sti{y}$, $xy=yx$ as a boolean variable, and systematically guesses possible solutions without considering their semantics as string constraints. E.g., the solver may guess $\neg(|x| = |y|)$, $(\sti{x} = \sti{y})$, and $(x =y)$. This is a valid guess if all the string constraints are just interpreted as boolean variables, but invalid when their semantics as string constraints are considered, because it cannot be the case that $x$ and $y$ are the same string $(x =y)$, but they are of different lengths $( \neg (|x| = |y|))$.


The approach combines techniques from both automata theory and SMT solving to explore the model space of a string constraint systematically. More specifically, an SMT solver based on the DPLL(T) algorithm~\cite{} is used to convert the satisfiability of a string constraint, which is an arbitrary boolean combination of string predicates, to the satisfiability problem of a set of string constraints in the form of conjunctions of string predicates.




}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overview} \label{section:overview}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Here we try to explain the approach using a toy example $\Phi = \{xy=yx, n = \sti{x}, n >3 ,|y|>|x|, y \in (12)^+\}$. Notice that $\Phi$ is satisfiable. E.g., it has a model $x=``12''$ and $y=``1212''$.

For proving UNSAT, our framework does not set any restriction on which decision procedure to use. One can select any decision procedure they want to use and ``over-approximate'' the input constraint to one that falls in the decidable fragment, e.g., the acyclic fragment~\cite{abdulla2014string}, the straight-line fragment~\cite{chen2019decision}, or the chain-free fragment~\cite{abdulla2019chain}. For instance, we can convert $xy=yx$ to two formulas $\{x_1=xy, x_2=yx\}$ using two auxiliary variables $x_1,x_2$ and remove the constraint $n=\sti{x}$. This produce new formulas that over-approximate the original ones and fall in the acyclic fragment~\cite{abdulla2014string}, which is decidable. Since $\Phi$ is satisfiable, the over-approximation module will not return UNSAT. 

Then our procedure will restrict the domain of each string variables to the language defined by some parametric flat automata (PFA) and convert them to equisatisfiable linear formula. The details of the under-approximation component will be described in Section~\ref{section:under_approximate}. Here we try to explain what the linear formula looks like by an example. Assume that we project the domain of $x$ and $y$ to the PFA in Figure~\ref{fig:sfa} (a) and (b), respectively. The variables $v_1$, $v_2$, $v_3$, $v_4$ in the figure are \emph{character} variables. One special treatment we do in this paper is that we encoding characters as natural numbers. So $v_1$, $v_2$, $v_3$, $v_4$ are also integer variables. For example, from the formula $ y \in (12)^+$, we may derive $v_3=1$ and $v_4=2$. 

The linear formula produced after the domain restriction will be over variables $v_1$, $v_2$, $v_3$, $v_4$,  as well as, the number of occurrences of each character variables $\#v_1$, $\#v_2$, $\#v_3$, $\#v_4$. Each model of the linear formula encodes a model of the string constraint. For example, $x=``12''$ and $y=``1212''$ is encoded by the assignment $(v_1,v_2,v_3,v_4,\#v_1,\#v_2,\#v_3,\#v_4)= (1,2,1,2,1,1,2,2)$. The assignment says, for example, that $x$ is the parametric word obtained by traversing the loop of $A_x$ once (because $\#v_1 = \#v_2 = 1$), which is $v_1v_2$. Under the assignment $v_1=1$ and $v_2=2$, we obtain $x=``12''$.

If a model of the produced linear formula is found, then the procedure concludes SAT with an assignment to the string variables.  If not, our procedure step-wisely change the PFA to more expressive ones (by adding more states and transitions) to systematically search for the solution. Depending on the implementation, one may choose to report unknown after some certain steps.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Preliminaries} \label{section:preliminary}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%We use $\mathbb{N}$ and $\mathbb{Z}$ to denote the sets of natural numbers and 
%integers. For a set $A$, we use $|A|$ to denote its size. For a string $w$, we 
%use $|w|$ to denote its length and $|w|_a$ to denote the number of occurrences of $a$ in $w$. We $\epsilon$ to denote an empty string and use $w_1\cdot w_2$ to denote the concatenation of strings $w_1$ and $w_2$. Let $S$ be a finite set of symbols. We use $S^+$ to denote the set of string over $S$ and $S^* = S^+\cup \{\epsilon\}$. We define $S_\epsilon =S\cup\{\epsilon\}$. A language 
%$L$ over $S$ is a set of strings in $S^*$. 
%
%A \emph{finite automaton} is a tuple $(Q,T,\Sigma,q_0,q_m)$, where $Q$ is the set of states, $T\subseteq Q\times (\Sigma\cup \{\epsilon\} )\times Q $ is the set of transition relation, $\Sigma$ is the alphabet, $q_0$ is the initial state, and $q_m$ is the final state. The semantics of finite automaton is defined in the standard manner. We use $L(A)$ to denote the regular language, i.e., set of accepted strings, of the automaton $A$.

%Given a finite automaton $A$ over $\{a_1,a_2,\ldots,a_n\}$, the Parikh image of $L$ is the set $\{(|w|_{a_1},\ldots, |w|_{a_n}) \mid w \in  L(A) \}$, i.e., the number of occurrences of each symbol $\{a_1,a_2,\ldots,a_n\}$ of words in $L(A)$. Moreover, one can construct from $A$ in linear time a Presburger formula $\phi_A(v_1, \ldots,v_n)$ such that $\phi(c_1, \ldots,c_n) \iff (c_1, \ldots,c_n)$ in the Parikh image of $L$~\cite{SeidlSMH04}.

We use $\mathbb{N}$ and $\mathbb{Z}$ to denote the sets of natural numbers (including 0) and 
integers. For a set $A$, we use $|A|$ to denote its size. 
For $n,m\in\nat$, we write $[n,m]$ for the set of natural numbers 
%(or symbols in $\Sigma$) 
$\{k\mid n\leq k \leq m\}$. 
An \emph{alphabet} is a finite set $\Sigma$ of \emph{characters} and a \emph{word} over $\Sigma$ is a sequence $w = a_1\ldots a_n$ of characters from $\Sigma$, with $\epsilon$ denoting the \emph{empty word}. 
We use $w_1\cdot w_2$ to denote the \emph{concatenation} of words $w_1$ and $w_2$.
$\Sigma^*$ is the set of all words over $\Sigma$, $\Sigma^+ = \Sigma^*\setminus \{\epsilon\}$, $\Sigma_\epsilon = \Sigma\cup\{\epsilon\}$, and 
A \emph{language} over $\Sigma$ is a subset $L$ of $\Sigma^*$.  
%
We use $|w|$ to denote the length of $w$ and $|w|_a$ to denote the number of occurrences of the character $a\in \Sigma$ in $w$.  

A \emph{finite automaton} (FA) is a tuple $(Q,T,\Sigma,q_i,q_f)$, where $Q$ is the set of \emph{states}, $T\subseteq Q\times \Sigma \times Q $ is the set of \emph{transitions}, $\Sigma$ is the alphabet, $q_i$ is the \emph{initial state}, and $q_f$ is the \emph{final state}. 
%The semantics of finite automaton is defined in the standard manner. 
A \emph{run} of $A$ over a word $w = a_1\cdots a_n$ is a sequence of transition $(q_0,a_1,q_1),(q_1,a_1,q_2),\ldots,(q_{n-1},a_n,q_n)$. The run  is \emph{accepting} if $q_0 = q_i$ and $q_i = q_f$ and $w$ then is \emph{accepted}.
The \emph{language} of $A$ is the set $L(A)$ of all accepted words.

Through the paper, we will use quantifier-free linear integer arithmetic formulas, and call them \emph{linear formulas} for short.   
Given a linear formula $\phi$, a set of variables $V$ \lh{remove this?: that includes all variables occurring in $\phi$}, and an \emph{interpretation} of $V$, i.e., a function $I:V\rightarrow \nat$, 
we denote by $I\models_V \phi$ that $I$ satisfies $\phi$ (which is defined in the standard manner), and call $I$ a \emph{model} of $\phi$ over $V$. \lh{Our use of indexing by $V$ in the text later is not very nice. Add this for clarity?: If $V$ contain additional variables not present in $\phi$, the these might be assigned arbitrary values by $I$. If $V$ is missing some of the variables of $\phi$, then it must be possible to complete $I$ with assignment of the missing variables into a satisfying assignment of $\phi$ (as in existential quantification).}
We use $\modelsof \phi$ to denote the set all models of $\phi$ over $V$. 
We drop the reference to $V$ and write just ``model of $\phi$'',  $\modelsof \phi$, and $\models$ when no confusion may arise. For a set of interpretations $S$, we use $S_\Sigma$ to denote the set of interpretations obtained from $S$ by projecting the domain to $\Sigma$.

The \emph{Parikh image} of a word $w\in \Sigma^*$ is the assignment 
$\parikhof w$ that for every character $a\in\Sigma$ maps the \emph{Parikh variable} $\#a$ to the number of occurrences of $a$ in $w$.
Formally, let $\pvarsof S$ denote the set of Parikh variables $\{\#s \mid s\in S\}$ obtained from a set $S$. 
The Parikh image of $w$ is a function $\parikhof w:\pvarsof \Sigma \rightarrow \nat$ such that $\parikhof w (\#a) = |w|_a$. 
The Parikh image of a language $L$ is the set of Parikh images $\parikhof L = \{\parikhof w \mid w \in  L\}$ and the Parikh image of an FA $A$ is Parikh image of its language, $\parikhof{A} = \parikhof{L(A)}$. 
%
It is well known that $\parikhof A$ can be efficiently computed in the form of linear formula:



\begin{lemma}[\cite{SeidlSMH04}]
$\parikhof{A}$ of an FA $A$ can be computed in the form of a linear formula  $\parikhfof{A}$ such that $\modelsof{\parikhfof A}_{\#\Sigma} = \parikhof{A}$, in time linear to the size of $A$.
\end{lemma}



 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{String Constraints} \label{section:sc}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


In this section, we formally define string constraints. To begin with, we fix an finite alphabet $\Sigma \subseteq \mathbb{N}$. Note that here we assume the alphabet is a finite subset of natural numbers. Essentially, we try to capture the numerical encoding of the corresponding symbols in computers (e.g., in ASCII, `A' is encoded as $65$). We assume there is an one-one mapping between numbers in $\Sigma$ and the character it encodes. For the simplicity of presentation, we assume the character `$0$' is mapped to the number $0$, `$1$' to $1$,$\ldots$, and `$9$' to $9$. For other character $c$, we use $\enc{c}$ to denote the number that it maps to. Notice that this approach is general enough to support any finite set of characters. 


We call $\vars$ the set of \emph{string variables} ranging over $\Sigma^*$ and $\varn$ the set of \emph{integer variables} ranging over $\mathbb{Z}$.
For a variable $x$, we call its primed version (e.g., $x'$) or indexed versions (e.g., $x_1$) its \emph{variants}.
In this paper, we use $x,y$ (or their variants) to denote string variables and $n$ (or its variants) to denote integer variables.

An \emph{interpretation over $\vars$ and $\varn$} is a mapping $I$ from $\vars\cup \varn$ to $\Sigma^* \cup \mathbb{N}$. A \emph{term} is an element in $(\vars\cup \Sigma)^*$. We lift the interpretation $I$ to terms and linear constraints in the standard manner. 

An \emph{equality constraint} $\phi_e$ is of the form $t_1 = t_2$ where $t_1, 
t_2$ are terms in $(\vars\cup \Sigma)^*$. The \emph{model} of $\phi_e$ is the set of interpretations $\modelsof{\phi_e}=\{I\mid 
I(t_1)=I(t_2)\}$. A \emph{disequality constraint} $\phi_d$ is of the form $t_1 \neq 
t_2$ and is interpreted analogously.

An \emph{integer constraint} $\phi_i$ is a linear constraint over the variables in $\varn$ and length of a word $|x|$ for all $x \in \vars$.
%Formally, assume that $\vars=\{x_i,\ldots,x_n\}$ and $\varn=\{y_i,\ldots,y_m\}$, a length constraint is of the form $(\sum_{i\in[1,n]}(j_i \times \sti{x_i}+k_i\times |x_i|)+ \sum_{i\in[1,m]}(l_i \times y_i)) \odot k$, where $\odot \in \{>,\geq, =, \leq, <\}$, and $j_i,k_i,l_i,k\in \mathbb{Z}$. We define $\modelsof{\phi}= \{I \mid (\sum_{i\in[1,n]}(j_i \times \sti{I(x_i)}+k_i\times |I(x_i)|)+ \sum_{i\in[1,m]}(l_i \times I(y_i))) \odot k \}$.
We define  $\modelsof{\phi_i}= \{I \mid I(\phi_i)= \true \}$.

A \emph{regular constraint} $\phi_r$ is of the form $x \in L(A)$ where $x$ is a string variable and $A$ is a finite automaton. The \emph{model} of $\phi_m$ is the set of interpretations $\modelsof{\phi_m}=\{I\mid 
I(x) \in L(A) \}$. 

The \emph{string-number conversion constraint} $\phi_s$ is of the form $n=\sti{x}$, where the function $\sti{x}$ is defined as follows. For $a\in [0,9]$, we have $\sti{a}=a$ and for $s \cdot a \in [0,9]^+$, $\sti{s\cdot a} = 10\times \sti{s}+a$. For $s\notin [0,9]^+$, $\sti{s}=-1$. We define  $\modelsof{\phi_s}= \{I \mid I(n)= \sti{I(x)} \}$.

A \emph{string constraint} is a constraint of the above form. We say that a set of string constraint $\Phi$ is \emph{satisfiable}  iff $\bigcap_{\phi \in \Phi} \modelsof{\phi}$ is not empty.

Notice that only positive integer is supported in the string-number conversion function. This is the semantics used by most of the SMT solvers, and hence we follow it in this paper. The encoding has a benefit that it can also handle the case where $x$ is ``not a number'', using the condition $\sti{x} = -1$.

Supporting only positive integer is not a strong restriction, since conversing from negative integer can still be encoded using the positive only version. More specifically, if we want to say $n \in \varn$ is the integer value of the string $x \in \Sigma^*$, we can write the following constraint (ignore the case that $x$ is ``not a number'', which can also be encoded using more conditions):
$$(n= \sti{x}) \vee (n=-\sti{x'} \wedge x = \enc{-}\cdot x')$$
Recall that $\enc{-}$ is the integer encoding of the minus symbol `$-$'. The \emph{number-string conversion function} $\its{n}$ is defined symmetrically. We have $x = \its{n}$ iff $y= \sti{n}$. 


\section{Under-approximation} \label{section:under_approximate}
In this section, we describe formally how to restrict the domain of string variables to patterns defined by \emph{parametric flat automata} (PFA) (Section~\ref{section:sfa}) and hence convert string constraints $\Phi_I$ to a set of equisatisfiable linear formulas $\Phi_O$ in polynomial-time. We assume all disequality constraint $t_1 \neq t2$ are already converted to equal-satisfiable equality constraints and integer constraints in the standard way~\cite{abdulla2015norn}. 

We pick a PFA for each variable in $\vars$ at the beginning of the decision procedure and then construct the set of linear integer constraints in a stepwise manner. In each step, we take a string constraint from $\Phi_I$ and depending on the type of the string constraint, we execute the corresponding procedure to produce the linear integer constraints and add them to the output linear formulas $\Phi_O$. 

More concretely, at the beginning, we move all integer constraints in $\Phi_I$ to the output linear formulas $\Phi_O$. After this step, $\Phi_I$ is the union of the three sets of constraints: the equality constraints, the regular constraints, and the string-number conversion constraints. For all string variables $x$ that occurs in a string-number conversion constraint $n= \sti{x}$, we follow the rule that will be described in Section~\ref{section:s2i} to pick the corresponding PFA. We do not set any restriction to the selection of PFA for other string variables. The selection is an implementation decision. We will describe the PFA selection strategy of \tool in Section~\ref{section:implementation}. 

After the PFA for each variable is selected, we step-wisely pick and remove a string constraint from $\Phi_I$, executing the corresponding procedure to create equisatisfiable linear constraints, and add all the results to $\Phi_O$. The procedures for regular, equality and string-number conversion constraints are in Sections~\ref{section:mem},~\ref{section:eq}, and~\ref{section:s2i}, respectively.


 



\hide{We replace it with the following constraints.
	
	$$
	\begin{array}{c}
	(|x_1|+ |x_2|+ \cdots +|x_n| \neq |x_{n+1}| + |x_{n+2}|+ \cdots +|x_m|)\vee \\
	\left(
	\begin{array}{cccc}
	
	y_1\cdot y_2\cdot y_3 &=& x_1\cdot x_2 \cdots x_n &\wedge\\
	y_1 \cdot y'_2 \cdot y'_3 &=& x_{n+1}\cdot x_{n+2} \cdots x_m &\wedge\\
	|y_2|&=&|y'_2|=1
	\end{array}
	
	\right)
	\end{array}
	$$
	
	The second disjunct says that the constraints $x_1\cdot x_2 \cdots x_n$ and $x_{n+1}\cdot x_{n+2} \cdots x_m$ have a common prefix $y_1$, but the next character $y_2$ and $y'_2$ is different. In an more efficient implementation, one just project $y_2$ and $y'_2$ to a PFA that accept only symbolic words $v_1$ and $v'_1$, respectively (the PFA has no loop and only one transition). }


\yfc{say handling regular constraint can be exponential to the number of constraints, but in our under-approximation, it is polynomial.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Parametric Flat Automata} \label{section:sfa}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\st}[2]{q_{#1}^{#2}}
\newcommand{\sym}[2]{v_{#1}^{#2}}
\todo{additional presburget constraints to encode $\epsilon$ added at translation to a formula}
%We use $\cvar$ to denote a finite set of \emph{character variables}  ranging over $\Sigma_\epsilon$. 
%Sometimes we use index to denote different set of variables over the same range, e.g., $\cvarone$ and $\cvartwo$. 
%We use $v$ and its variants for character variables. We call a string over $\cvar$ (character variables) a \emph{symbolic string}.
%An \emph{interpretation $I$ over $\cvar$} is a mapping from $\cvar$ to $\Sigma_\epsilon$. For a symbolic string $x= v_1v_2\cdots v_k$ over $\cvar$, $I(x)$ is defined as $I(v_1)\cdot I(v_2)\cdot \ldots \cdot I(v_k)$.



We introduce \emph{parametric flat automata} (PFA) that will be used to define patterns 
used by the under-approximation module to restrict the domain of string variables. 
A \emph{parametric automaton} (PA) is a finite automaton operating over an alphabet $\cvar$ of \emph{character variables}. 
A parametric flat automaton is a parametric automaton $A = (Q,T,\cvar,\st{0}{0},\st{m}{0})$ satisfying the following structural constraints:
\begin{enumerate}
	\item The final state $\st{m}{0}$ is reached from  the initial state $\st{0}{0}$ through a straight path of $m-1$ transitions $(\st{i}{0},v_i,\st{i+1}{0}) \in T$, $\st{i}{0} \in Q$ for $i\in[0,m-1]$. %, with pairwise distiand states $\st{i}{0} \in Q$ for $i\in[0,m-1]$.
	\item  
Each state $\st{i}{0}$ is the origin of a unique simple cycle of the length $l_i\in\mathbb{N}$, consisting of states $\st{i}{j-1} \in Q$ and transitions $(\st{i}{j-1}, \sym{i}{j-1}, \st{i}{j \bmod l_i})$ for $j\in [1,l_i]$. 
Notice that case when $l_i = 0$ is also admissible and means that there is no cycle on $q_i$.
%Assume that $\st{i}{0}$ is included in a cycle with $l_i$ states (includes $\st{i}{0}$). 
%For each $j\in [1,l_i]$, we have $\st{i}{j} \in Q$ and $(\st{i}{j-1}, \sym{i}{j-1}, \st{i}{j \bmod l_i})$. 
%(where $l_i = 0$ means that there is no cycle on $q_i$)
	\item Each variable in $\cvar$ appears on at most one transition.% (but $\epsilon$ transition can appear multiple times). 
\end{enumerate} 
\begin{figure*}
	\tikzset{state/.style={circle,draw=blue!50,fill=blue!20,
			thick,inner sep=0pt,minimum size=6mm}, initial text=$ $}
	\begin{tikzpicture} 
		\node[state,initial] (q0)  {$\st{0}{0}$};
		\node[state] (q1) [right = 3cm of q0] {$\st{1}{0}$};
		\node (q2) [right = 1.8cm of q1]{};
		\node (q3) [right = 1cm of q2]{};
		\node[state,accepting] (qm) [right = 1.8cm of q3] {$\st{m}{0}$};
		
		\node[state] (q01) [above left = 0.6cm of q0] {$\st{0}{1}$};
		\node[state] (q02) [above = 1cm of q0] {$\st{0}{2}$};
		\node[state] (q03) [above right = 0.6cm of q0] {$\st{0}{3}$};

		\node[state] (q11) [above left = 0.8cm of q1] {$\st{1}{1}$};
		\node[state] (q12) [above right = 0.8cm of q1] {$\st{1}{2}$};

		\node[state] (qm1) [above left = 0.6cm of qm] {$\st{m}{1}$};
		\node[state] (qm2) [above = 1cm of qm] {$\st{m}{2}$};
		\node[state] (qm3) [above right = 0.6cm of qm] {$\st{m}{3}$};

  		\draw[->] (q0) edge [bend left] node [left]{$\sym{0}{0}$} (q01) ;
  		\draw[->] (q01) edge [bend left] node [left]{$\sym{0}{1}$} (q02) ;
  		\draw[->] (q02) edge [bend left] node [right]{$\sym{0}{2}$} (q03) ;
  		\draw[->] (q03) edge [bend left] node [right]{$\sym{0}{3}$} (q0) ;
  		
  		\draw[->] (q0) edge node [below]{$v_0$} (q1) ;
  		\draw[->] (q1) edge node [below]{$v_1$} (q2) ;
  		\draw[dotted] (q2) edge (q3) ;
  		\draw[->] (q3) edge node [below]{$v_{m-1}$} (qm) ;

  		\draw[->] (qm) edge [bend left] node [left]{$\sym{m}{0}$} (qm1) ;
		\draw[->] (qm1) edge [bend left] node [left]{$\sym{m}{1}$} (qm2) ;
		\draw[->] (qm2) edge [bend left] node [right]{$\sym{m}{2}$} (qm3) ;
		\draw[->] (qm3) edge [bend left] node [right]{$\sym{m}{3}$} (qm) ;

  		\draw[->] (q1) edge [bend left] node [left]{$\sym{1}{0}$} (q11) ;
		\draw[->] (q11) edge [bend left] node [above]{$\sym{1}{1}$} (q12) ;
		\draw[->] (q12) edge [bend left] node [right]{$\sym{1}{2}$} (q1) ;
	\end{tikzpicture} 

	\caption{An example of a parametric flat automaton}
	\label{fig:sfa_def}
\end{figure*}

%A finite automaton $D=(Q,T',\Sigma,q_0,q_m)$ is an \emph{instance} of a PFA $S=(Q,T,\cvar,q_0,q_m)$, if there exists an interpretation $I: \cvar \cup \{\epsilon\} \rightarrow \Sigma_\epsilon$ satisfying $I(\epsilon)=\epsilon$ and $T'=\{(q,I(c),q')\mid (q,c,q')\in T\}$. We write $I(S)$ to denote the instance of $S$ wrt. $I$. The language of $S$ is defined as $L(S)= \cup\{L(D) \mid D \mbox{ is an instance of } S\}$. Notice that $L(S)$ is regular because every PFA has only finitely many instance and the finite union of regular languages are also regular.


%Such automata are recognizers of symbolic strings, i.e., strings over $\cvar$.
Parametric automata accept words over $\cvar$, called \emph{parametric words}, but we still use them as representations of languages over $\Sigma$. 
%
Namely, word over $\cvar$ are interpreted as words over $\Sigma$ given an assignment of characters to its character variables.  
%
Formally, an \emph{interpretation $I$ over $\cvar$} is a mapping from $\cvar$ to $\Sigma_\epsilon$ and for a parametric word $x= v_1v_2\cdots v_k$ over $\cvar$, $I(x)$ is defined as $I(v_1)\cdot I(v_2)\cdot \ldots \cdot I(v_k)$.
%
We define the semantics of $x$ as the set $\semof x$ of all possible interpretations of $x$, the semantics of a language $L\subseteq V^*$ is the union $\semof L = \cup_{x\in L} \semof{x}$ of semantics of its words, and the semantics $\semof A$ of an PFA is the semantics of its language. 

The crucial feature of parametric flat automata is that their semantics can be faithfully represented by a linear formula and handled efficiently by an SMT solver. 
\lh{, allowing to circumvent more costly automata algorithms and decision procedures. Concretize and justify this better?}\yfc{The two sentences below read a bit strange, maybe need to rephrase it.}\lh{made an attempt}
%
This is facilitated by the structural constraints of PFA, which guarantee that 
every parametric word $x\in L(A)$ is uniquely determined by its Parikh image $\parikhof{x}$, as formalized by the following lemma.  

\begin{lemma}\label{lemma:parikh}
For an PFA $A$ and $x,y\in L(A)$, if $\parikhof x = \parikhof y$ then $x = y$. 
\end{lemma}
%
Indeed, since every variable appears on at most one transition, then the $\parikhof x$ value of all variables appearing within the same cycle is the same, and it is equal to the number of repetitions of that cycle in the accepting run. 
%
The accepting run on $x$ (and so $x$ itself) can thus be reconstructed from $\parikhof x$. 
%
For example, in the automaton of Figure~\ref{fig:sfa_def}, 
from $\parikhwof x {v_0} = \parikhwof x {v_1} = \cdots = \parikhwof x {v_{m-1}}=1$ and $\parikhwof x {v^0_1}=\parikhwof x {v^1_1}=\parikhwof x {v^2_1}=2$ we derive that $x=v_0(v^0_1v^1_1v^2_1)^2v_1\cdots v_{m-1}$. 
We may say that $\parikhof x$ is an encoding of $x$, and define the decoding function $\decode A$ such that $\decode A(\parikhof x) = x$.
%

\begin{lemma}\label{lemma:decx}
For a PFA $A$, $L(A) = \{\decode A(\pim) \mid \pim\in\semof{\parikhfof A}\}$.
\lh{should we replace $\semof{\parikhfof A}$ by $\parikhof{A}$ here and almost everywhere?}
\end{lemma}
%
\begin{proof}
The function $\decode A$ can particularly be implemented as follows. Given $\pim:\pvars\rightarrow\nat$,
and assuming that the lengths of the loops of $A$ are $l_0,\ldots,l_{m-1}$, 
$\decode A(\pim)$ is constructed as the word $x_0 v_{0} \ldots v_{m-1} x_{m-1}$ where for each $i\in [0,m-1]$,
$x_i = (v_i^0 \cdots v_i^{l_{i-1}})^{\pvarsof {v_i^0}}$ if $l_i >0$ and $x_i = \epsilon$ if $l_i = 0$. 
\end{proof}

Since every word $w \in \semof{A}$ is obtained from a parametric word $x\in L(A)$ and an interpretation of character variables $I:\cvar\rightarrow\Sigma_\epsilon$ such that $w = I(x)$, and since $x = \decode A(\parikhof x)$, 
we may say that the assignment $I \cup \parikhof x$ uniting the interpretation $I$ and the Parikh image of the parametric word $x$ encodes $w$. Lemma~\ref{lemma:parikh} also implies that two different words are encoded by different united assignments (the Parikh image or the interpretation must be different), and hence we may extend the decoding function $\decode A$ to united assignments so that $\decode A(I \cup \parikhof x) = w$.
Encodings of words in $\semof{A}$ are encodings of parametric words of $L(A)$ paired with arbitrary interpretations of character variables $\cvar$, which are precisely all models of the formula $\parikhfof A$ interpreted over $\cvar\cup\pvarsof \cvar$, as formulated by the following corollary of Lemma~\ref{lemma:decx}:
%
\begin{corollary}\label{corollary:pfa}
For an PFA $A$ over character variables $V$,
$\semof{A} = \{\decode A(I\cup \pim) \mid I\cup\pim\in\semof{\parikhfof A}_{\cvar\cup\pvar}\}$.
%$\semof{A} = \{I(\decode A(\pim)) \mid \pim\in\semof{\parikhfof A},I:\cvars\rightarrow\Sigma_\epsilon\}$.
\end{corollary}
%
A minor technical difficulty is that we wish to work with pure arithmetic formulas, 
but we may also wish to specify when a character variable is assigned $\epsilon$, which is not a number. 
Hence, to allow purely arithmetic formulas to talk about the value $\epsilon$, we encode $\epsilon$ as $-1$.
In the further development, $\epsilon$ will mean $-1$ when working with arithmetic formulas constraining interpretations of character variables.

\paragraph{Synchronization of PAs}
\ \lh{changed the formulation of the next two paragraphs a bit, is it ok?}
We will now discuss a construction of the \emph{synchronization formula} for two PAs $A$ and $A'$. 
%over character variables $V$ and $V'$. 
It is a linear formula $\syncfof A {A'}$ 
%over $\cvarone\cup \cvartwo \cup \pvarone\cup\pvartwo$ 
that specifies how each word in the semantic intersection $\semof A \cap \semof {A'}$ is encoded by $A$ and by $A'$.
%
More precisely, the models of $\syncfof A {A'}$ represent pairs of word
encodings $(I\cup \parikhof{x})$ and $(I'\cup \parikhof{x'})$ such that $x\in L(A)$, $x'\in L(A')$, and 
$I(x) = I'(x')$.
% \in \semof{A}\cap\semof{A'}$.
The synchronization formula will be used in, e.g., the decision procedure of equality constraints $t_1=t_2$ to find a common interpretation of $t_1$ and $t_2$.  
%More precisely, the models of the synchronization formula $\syncfof A {A'}$ correspond to the set of all pairs of word
%encodings $(I\cup \parikhof{x})$ and $(I'\cup \parikhof{x'})$ such that $x\in L(A)$, $x'\in L(A')$, and 
%$I(x) = I'(x') \in \semof{A}\cap\semof{A'}$.%, which constitute the intersection.
% encodings $(I\cup \pim)\in \parikhof {A}$ and $(I'\cup \pim')\in\parikhof {A'}$ such that 
%$I(\decode A(I\cup \pim) = \decode {A'}(I'\cup \pim')$, which constitute the intersection.

Particularly, the synchronization formula is build for two PAs  
$A = (Q,T,\cvarone,q_i,q_f)$ and ${A'} = (Q',T',\cvartwo,q_i',q_f')$ such that $\cvarone \cap \cvartwo = \emptyset$. 
%
It is extracted from the \emph{asynchronous product} of $A$ and $A'$. 
%
The asynchronous product is an automaton that uses $Q\times Q'$ as the set of states and 
$\cvarone_\epsilon\times\cvartwo_\epsilon$
as the alphabet. 
%
Every accepting run of $\syncof A {A'}$ corresponds to a pair of accepting runs, 
a run of $A$ over a parametric word $x$ and a run of ${A'}$ over a parametric word $x'$. 
The word accepted by the run of $\syncof A {A'}$ induces constraints on the interpretations of $I$ of $\cvarone$ and $I'$ of $\cvartwo$ under which the two parametric words have the same interpretation, i.e. $I(x) = I'(x')$. 

Intuitively, when the product automaton $\syncof A {A'}$ takes a transition $((q_1,q_1'), (v,v'),(q_2,q_2'))$, 
it means the character variable $v$ and $v'$ should be assigned the same value,
$A$ transitions under $v$ from state $q_1$ to state $q_2$ and ${A'}$ from $q_1'$ to $q_2'$ under $v'$.
%
When $\syncof A {A'}$ takes a transition $((q_1,q_1'), (v,\epsilon),(q_2,q_1'))$, 
it means that the character variable $v$ should be assigned $\epsilon$, 
$A$ transitions under $v$ to $q_1$, and ${A'}$ takes no action, since no action is needed to match $A$'s reading of $\epsilon$ (hence consumes no symbol from the input word). Symmetrically, ${A'}$ might read a variable $v$ assigned $\epsilon$ and $A$ may stay.

Formally, the asynchronous product automaton is a tuple $\syncof A {A'} = (Q\times Q', \syncT, \cvarone_\epsilon \times \cvartwo_\epsilon, (q_i,q_i'),(q_f,q_f'))$, where the transition relation $\syncT$ is the minimal set satisfying the following:
%
\begin{itemize}
\item If $(q_1,v,q_2) \in T$ and $(q_1',v',q_2') \in T'$, then we have $((q_1,q_1'),(v,v'),(q_2,q_2'))\in \syncT$.
\item If $(q_1,v,q_2) \in T$, then for all states $q'\in Q'$, we have $((q_1,q'),(v,\epsilon),(q_2,q'))\in \syncT$.
\item If $(q_1',v',q_2') \in T'$, then for all states $q\in Q$, we have $((q,q_1'),(\epsilon,v'),(q,q_2'))\in \syncT$.
\end{itemize}	
%
%The we define of constraints that extract from $\syncof A {A'}$ pairs of united assignments (encodings of strings over $\Sigma$) that encode the same string. 
The synchronization formula $\syncfof{A} {A'}$ is extracted from $\syncof A {A'}$ as follows.
Its first part is the Parikh formula $\parikhfof {\syncof A {A'}}$ of the product, which encodes all runs of the product.
%
The second part is a constraint that extracts from a run of $\syncof A {A'}$ the corresponding runs of $A$ and of $A'$:
$$ \Psi_{\#} \defeq 
\left(\bigwedge_{v\in\cvarone}\#v = \sum_{x' \in \cvartwo_\epsilon} \#{(v,x')}\right)
\land
\left(\bigwedge_{v'\in\cvartwo} \#v' = \sum_{x \in \cvarone_\epsilon} \#{(x,v')}\right)
$$
Notice that $x,x'$ are either variables or $\epsilon$.
%\begin{enumerate}
%	\item for all $v \in \cvarone$, $\#(v) = \sum_{v' \in \cvartwo} \#{(v,v')}$   
%	\item for all $v \in \cvartwo$, $\#(v) = \sum_{v' \in \cvarone} \#{(v',v)}$ 
%\end{enumerate}
Finally, the third part forces the interpretations of the parametric words accepted by $A$ and $A'$ to be the same:
% condition 1. and 2. required for the pair of symbolic string $(w_n, w_m)$ and $I$, i.e., $I(w_n) = I(w_m)$ and $I$ assign the same value to all versions of the same variable (we use $-1$ as the value of $\epsilon$). 
$$ \Psi_= \defeq
\bigwedge_{x\in\cvarone_\epsilon,x'\in\cvartwo_\epsilon} \#(x,x')>0 \rightarrow (x=x')
$$
%\begin{enumerate}
%	\item for all $v\in \cvarone$ and $v'\in \cvartwo$, $\#{(v,v')}>0 \rightarrow (v=v')$, 
%	\item for all $v\in \cvarone$, $\#{(v,\epsilon)}>0 \rightarrow (v=\epsilon)$, and
%	\item for all $v\in \cvartwo$,$\#{(\epsilon,v')}>0 \rightarrow (v'=\epsilon)$.
%\end{enumerate}
The synchronization formula is then the conjunction 
$$
%\syncfof A {A'} = \exists \pvarsof{\cvarone\times\cvartwo}\exists {(\cvarone\times\cvartwo)}.\,\parikhfof{\syncof A {A'}} \land \Psi_{\#} \land \Psi_=
\syncfof A {A'} \defeq \parikhfof{\syncof A {A'}} \land \Psi_{\#} \land \Psi_=
$$

The correctness of this construction is stated in Lemma~\ref{lemma:synccorrect} below. The lemma can also be understood as a precise specification of the semantics of the synchronization formula, on which we rely for correctness of the construction of under-approximations of string constraints in Sections~\ref{section:mem}, \ref{section:eq}, and \ref{section:s2i}. 
%
\hide{
\begin{lemma}\label{lemma:synccorrect}
%$\semof {\exists V_\times . \syncfof A {A'}}\restrict{\cvarone \cup \cvartwo \cup \pvarsof{\cvarone} \cup \pvarsof\cvartwo} = \{(I\cup\pim)\cup(I'\cup\pim') \mid \decode A(I\cup\pim) = \decode {A'}(I'\cup\pim')\}$. 
$\semof {\syncfof A {A'}}_{\cvarone\cup \cvartwo \cup \pvarone\cup\pvartwo} = \{(I\cup\pim)\cup(I'\cup\pim') \mid \decode A(I\cup\pim) = \decode {A'}(I'\cup\pim')\}$. 
\end{lemma}
%
Another version:}
\begin{lemma}\label{lemma:synccorrect}
$
\semof {\syncfof A {A'}}_{\cvarone\cup \cvartwo \cup \pvarone\cup\pvartwo} = 
\{
(I\cup\parikhof{x})\cup(I'\cup\parikhof{x'}) \mid 
x\in L(A), x'\in L(A'), I(x) = I(x')
\}
$
\end{lemma}
Informally, the lemma states that the models of $\syncfof A {A'}$ encode precisely the pairs of equivalent encodings of words from $\semof{A}$ and $\semof{A'}$, that constitute the intersection $\semof{A} \cap \semof{A'}$. A minor technical difficulty is that the models of $\syncfof A {A'}$ include also an assignment to the auxiliary variables of $(\cvarone_\epsilon\times\cvartwo_\epsilon) \cup \pvarsof{(\cvarone_\epsilon\times\cvartwo_\epsilon)}$. Hence in the lemma, we have to restrict the models to the original variables $\cvarone \cup \cvartwo \cup \pvarsof{\cvarone} \cup \pvarsof\cvartwo$. %This is  achieve by quantifying out the variables of $V_\times$.

Notice that if $A$ is flat (or, symmetrically, if $A'$ is flat), then the semantic intersection $\semof A \cap \semof {A'}$ can be still decoded from the synchronisation formula $\semof {\syncfof A {A'}}$. 
Namely, due to Corollary~\ref{corollary:pfa}, we have that $\semof A \cap \semof {A'} = \{\decode A(I\cup \pim) \mid (I\cup \pim) \in \semof{\syncfof A {A'}}_{\cvarone\cup \pvarone}\}$.  


%We actually have even something stronger, namely, that, $\syncfof A {A'}$ has all possible allignments. How do I say this ... or do I have to say this?
%\begin{lemma}
%For $\pim:\pvarone\rightarrow \nat$, $\pim':\pvartwo \rightarrow\nat$, $I:\cvarone\rightarrow\Sigma$, $I':\cvartwo\rightarrow\Sigma$, 
%we have $(I\cup\pim)\cup(I'\cup\pim')\in\semof {\syncfof A {A'}}$ if and only if $\decode A(I\cup\pim) = \decode {A'}(I'\cup\pim')$.
%\end{lemma}

\lh{this following sentence appears to be in a wrong place here. Would be nicer in some introductory part to the underapproximation which talks about this, but I don't know where it should be.}
In the rest of the section, we assume each string variable $x$ is restricted to a PFA $A_x$ with the set of character variables~$V_x$.

\yfc{we need to define \#{V} somewhere}
\lh{it is in prelims next to Parikh im. definition}

\subsection{Handling Regular Constraints Symbolically} \label{section:mem}

Assume that the constraint we take from $\Phi_I$ is a regular constraint $\phi_r \defeq x \in L(A)$. Assume that $A=(Q,T,\Sigma,q_i,q_f)$. First we create a PA $A' = (Q,T', V',q_i,q_f)$ that has exactly the same set of states as $A$. The set of transitions $T'$ and character variables $V'$ is defined as follows:

\begin{itemize}
	\item $V' = \{ v_{(q,a,q')} \mid (q,a,q')\in T\}$
	\item $T' = \{ (q, v_{(q,a,q')}, q')  \mid (q,a,q')\in T\}$
\end{itemize}
We use the linear formula $\phi_c \defeq \bigwedge\limits_{(q,a,q')\in T} (v_{(q,a,q')} = a)$ to remember the relation between the fresh character variables in $V'$ and the symbol it represents. The relation between $A$ and $A'$ is expressed in Lemma~\ref{lemma:fa_pfa}.

\begin{lemma}\label{lemma:fa_pfa}
	$L(A) =  \{  \decode {A'}(I\cup\pim) \mid (I\cup\pim)\in  {\semof {\parikhfof {A'} \wedge \phi_c}} _{V' \cup \#V'} \}$. 
\end{lemma}

Intuitively, we create a new character variable for each transition in $T$, later we will add the relation $v_{(q,a,q')}  = a$ to $\Phi_O$.


The correctness of this construction is expressed in Lemma~\ref{lemma:memcorrect} below. 
%
%\newcommand\restrict[1]{\raisebox{-.5ex}{$\big|$}_{#1}}
\begin{lemma}\label{lemma:memcorrect}
	$({\semof {\syncfof {A_x }{A'}} \cap \bigcap_{\phi\in\Phi_C} \semof {\phi} } )_{V_x \cup \#V_x} = \{(I\cup\pim) \mid \decode {A_x}(I\cup\pim) \in L(A)\}$. 
\end{lemma}

\lh{Simplified version:
Assume that the constraint we take from $\Phi_I$ is a regular constraint $\phi_r \defeq x \in L(A)$. 
%Assume that $A=(Q,T,\Sigma,q_i,q_f)$. 
We represent the FA $A$ by a pair of a PA $A'$ and linear formula $\phi_A$. 
The PA $A'$ operates over fresh character variables $v_a, a\in\Sigma_\epsilon$, and is obtained from $A$ by replacing every occurrence of each character $a\in\Sigma_{\epsilon}$ on a transition by the variable $v_a$. 
The formula $\phi_A$ then binds the fresh variables to the characters they represent, 
namely, $\phi_A = \bigwedge_{a\in\Sigma_\epsilon} v_a = a$.
The resultinng overapproximation of $\phi_r$ is then the formula $\syncfof{A_x} {A'} \land \phi_A$.

The following lemma states the correctness of this construction: Intuitively, the resulting constraint represents presicely the restriction of $L(A)$ to the domain $\semof{A_x}$, the $A_x$-encodings of the strings in $L(A)\cap\semof{A_x}$. 
%
\begin{lemma}\label{lemma:memcorrect}
	${\semof {\syncfof {A_x }{A'} \land \phi_A} } _{V_x \cup \pvarsof{V_x}} = \{(I\cup\pim) \mid \decode {A_x}(I\cup\pim) \in L(A)\}$. 
\end{lemma}
}





\begin{figure*}
	\tikzset{state/.style={circle,draw=blue!50,fill=blue!20,
			thick,inner sep=0pt,minimum size=6mm}, initial text=$ $}
	
	\begin{minipage}[t]{0.15\textwidth} 
		\begin{tikzpicture}
		\node[state,initial,accepting] (q0)  {$q_0$};
		
		\node[state] (q01) [above = 0.5cm of q0] {$q_1$};
		
		\draw[->] (q0) edge [bend left] node [left]{$v_0$} (q01) ;
		\draw[->] (q01) edge [bend left] node [right]{$v_1$} (q0) ;
		\end{tikzpicture} 
		
		\centering
		(a) $A_x$
	\end{minipage}
	\begin{minipage}[t]{0.15\textwidth} 
		\begin{tikzpicture} 
		\node[state,initial,accepting] (q0)  {$p_0$};
		
		\node[state] (q01) [above = 0.5cm of q0] {$p_1$};
		
		\draw[->] (q0) edge [bend left] node [left]{$v_2$} (q01) ;
		\draw[->] (q01) edge [bend left] node [right]{$v_3$} (q0) ;
		\end{tikzpicture} 
		
		\centering
		(b) $A_y$
	\end{minipage}
	\begin{minipage}[t]{0.28\textwidth}
		\begin{tikzpicture} 
		\node[state,initial] (q0)  {$q_0$};
		\node[state,accepting] (q1) [right = 1.3cm of q0] {$p_0$};
		
		\node[state] (q01) [above = 0.5cm of q0] {$q_1$};
		
		\draw[->] (q0) edge [bend left] node [left]{$v_0^{(0)}$} (q01) ;
		\draw[->] (q01) edge [bend left] node [right]{$v_1^{(0)}$} (q0) ;
		
		\node[state] (q11) [above = 0.5cm of q1] {$p_1$};
		
		\draw[->] (q1) edge [bend left] node [left]{$v_2^{(0)}$} (q11) ;
		\draw[->] (q11) edge [bend left] node [right]{$v_3^{(0)}$} (q1) ;
		\draw[->] (q0) edge  node [below]{$v_{\epsilon_0}$} (q1) ;
		\end{tikzpicture}
		
		\centering
		(c) $A_{xy}$
	\end{minipage}
	\ \ \ 
	\begin{minipage}[t]{0.28\textwidth}
		\begin{tikzpicture} 
		\node[state,accepting] (q0)  {$q_0$};
		\node[state,initial] (q1) [left = 1.3cm of q0] {$p_0$};
		
		\node[state] (q01) [above = 0.5cm of q0] {$q_1$};
		
		\draw[->] (q0) edge [bend left] node [left]{$v_0^{(1)}$} (q01) ;
		\draw[->] (q01) edge [bend left] node [right]{$v_1^{(1)}$} (q0) ;
		
		\node[state] (q11) [above = 0.5cm of q1] {$p_1$};
		
		\draw[->] (q1) edge [bend left] node [left]{$v_2^{(1)}$} (q11) ;
		\draw[->] (q11) edge [bend left] node [right]{$v_3^{(1)}$} (q1) ;
		\draw[->] (q1) edge  node [below]{$v_{\epsilon_1}$ }(q0) ;
		\end{tikzpicture}
		
		\centering
		(d) $A_{yx}$
	\end{minipage}
	
	\caption{Parametric flat automata of $x$, $y$, $xy$ and $yx$}
	\label{fig:sfa}
\end{figure*}



\subsection{Handling Equality Constraints Symbolically} \label{section:eq}

Assume that the constraint we take from $\Phi_I$ is an equality constraint $\phi_e\defeq x_1\cdot x_2 \cdots x_n = x_{n+1}\cdot x_{n+2} \cdots x_m$. We first build two PFAs that encode the left-hand side term and the right-hand side term of the equality constraint. Intuitively, this can be achieved by connecting the PFAs of the string variables with epsilon transitions. However, there are two minor technical issues. First, our definition of PFA does not allow epsilon transition. Second, some string variable might occur multiple times in a equality constraint, but the definition of PFA allows each character variable occurs in only one transition. \lh{the second is maybe not a minor technical issue}

We circumvent the first problem by introducing some fresh characters variables, say $v_{\epsilon_n}$, and forcing its value to be $\epsilon$ by adding new linear formulas, say $v_{\epsilon_n}= -1$, to the output linear formulas $\phi_O$. Then we can connect the final state and initial state of two consecutive variables with an ``epsilon'' transition, i.e., one with the label $v_{\epsilon_n}$. %We use $V_\epsilon$ to denote the set of all variables used for ``epsilon'' transitions.

For the second problem, we rename the variables on the transitions of PFAs for different occurrences of the same variable in one equality constraint. The renaming is done by adding a version number to the variable. We call variables before and after renaming the \emph{original variable} and the \emph{renamed variable}. For example, we can rename $v_1$ to $v_1^{(0)}$, $v_1^{(1)}$, etc. In this case, $v_1$ is the original variable and both $v_1^{(0)}$ and $v_1^{(1)}$ are the renamed variables. For an original variable $v$, we use $R_v$ to denote the set of variables renamed from $v$. Later we will add arithmetic constraints to enforce that variables obtained from the same original variable are assigned the same value. 
\lh{I did not find those, are they somewhere or forgoten?}

Here we give a concrete example. For the equality constraint $xy = yx$, assume that we restrict the domains of $x$ and $y$ to the PFA in Figure~\ref{fig:sfa} (a) and (b), respectively. In the construction of the PFA for $xy$ and $yx$ (Figure~\ref{fig:sfa} (c) and (d)), we rename the variables on the PFA of $X$ and $Y$ to some fresh variable for each different occurrence of $x$ and $y$ in $xy = yx$, connect the PFA after renaming with ``epsilon'' transitions (those labeled $v_{\epsilon_0}$ and $v_{\epsilon_1}$), and add linear formulas $v_{\epsilon_0}=-1$ and $v_{\epsilon_1}=-1$ to the output linear formulas $\phi_O$.

Now let $A$ and $A'$ over character variables $V$ and $V'$ be the two PFAs obtained from the two sides of the equality constraint $\phi_e$. We then construct the synchronization formula $\syncfof A {A'}$ and add it to $\Phi_O$. Recall that from Lemma~\ref{lemma:synccorrect}, each model of $\syncfof A {A'}$ corresponds to a pair of words in $\semof{A}$ and $\semof{A'}$. However, this does not directly correspond to a model of the equality constraint $\phi_e$. The reason is that difference occurrence of the same string variables can be assigned different values in $\semof{A}$ and $\semof{A'}$. To avoid this problem, we need to add the constraint $\Psi_r$ below to $\Phi_O$ to ensure that all variables renamed from the same original variable are assigned the same value and are occurred equally often.

$$ \Psi_r \defeq
\bigwedge_{v\in V_X, v'\in R_v} v=v' \wedge \#v = \#v'
$$
Here $V_X$ is the set of all character variables occurred in the PFAs of $x_1,x_2,\ldots,x_m$, i.e., $V_X=\bigcup_{i\in [1,m]}{V_{x_i}}$. \lh{what is $R_v$?}

The correctness of this procedure is stated in Lemma~\ref{lemma:eqcorrect}.


\begin{lemma}\label{lemma:eqcorrect}
	$\semof {\syncfof A {A'}  \wedge \Psi_r}_{V_X \cup \#V_X} = \{\bigcup_{i\in[1,m]}(I^i\cup\pim^i)\mid w_1\cdot w_2 \cdots w_n = w_{n+1}\cdot w_{n+2} \cdots w_m \wedge \bigwedge_{i\in [1,m]}w_i=\decode A_{x_i}(I^i\cup\pim^i) \}$.\lh{aaarrrghhh ... } 
\end{lemma}

\hide{
Assume that $S_n=(Q,T,\cvarone,q_i,q_f)$ is the PFA of $x_1\cdot x_2 \cdots x_n$ and $S_m=(P,T',\cvartwo,p_i,p_f)$ is the PFA of $x_{n+1}\cdot x_{n+2} \cdots x_m$. Our next task is to find a model for $x_1\cdot x_2 \cdots x_n = x_{n+1}\cdot x_{n+2} \cdots x_m$ under the domain restriction specified by $S_n$ and $S_m$. 
Note that $\cvarone \cap \cvartwo =\emptyset$, because all variables will be renamed to some fresh variable. 


This is equivalent to finding a pair of symbolic strings $(w_n,w_m) \in L(S_n)\times L(S_m)$ and a common interpretation $I$ such that 
\begin{enumerate}
	\item $I(w_n)=I(w_m)$
	\item $I$ assign to variants of the same variable the same value. For example, in Figure~\ref{fig:sfa} (c) and (d), $v_0^{(0)}$ and $v_0^{(1)}$ should be assigned the same value.
	\item different versions of the same variable should occurs equally often in $w_n\cdot w_m$. For example, in Figure~\ref{fig:sfa} (c) and (d), $w_{xy}=v_0^{(0)}v_1^{(0)}v_0^{(0)}v_1^{(0)}$ and $w_{yx}=v_0^{(1)}v_1^{(1)}v_0^{(1)}v_1^{(1)}$ is a pair of symbolic strings satisfying this condition. The number of occurrences of $v_i^{(0)}$ is the same to $v_i^{(1)}$ for $i\in[0,1]$ in the concatenation $w_{xy}\cdot w_{yx}$.
	But the pair $v_0^{(0)}v_1^{(0)}v_0^{(0)}v_1^{(0)}$ and $v_2^{(0)}v_3^{(0)}v_2^{(0)}v_3^{(0)}$ does not satisfy the condition. Observe that $v_0^{(0)}$ occurs twice, but $v_0^{(1)}$ is not there.
\end{enumerate}

In order to find such a pair of symbolic strings $(w_n,w_m) \in L(S_n)\times L(S_m)$ and an interpretation $I$, we first build a ``product'' automaton of $S_n$ and $S_m$ and then add some additional linear arithmetic constraints to enforce the above conditions.

Such product automaton uses $Q\times P$ as the set of states and 
%$(\cvarone \cup \{\epsilon\}) \times (\cvartwo \cup \{\epsilon\} )$ 
$\cvarone\times\cvartwo$
as the alphabet. If a transition $((q_1,p_1), (v,v'),(q_2,p_2))$ is taken, it means the character variable $v$ and $v'$ should be assigned the same value and this value leads $A$ from state $q_1$ to state $q_2$ and $B$ from $p_1$ to $p_2$.

More precisely, the product automaton is a tuple $\syncof A B = (Q\times P, \syncT, (\cvarone \cup \{\epsilon\}) \times (\cvartwo \cup \{\epsilon\} ), (q_i,p_i),(q_f,p_f))$, where the transition relation $\syncT$ is the minimal set satisfying the following.

\begin{itemize}
\item If $(q_1,v_i^{(j)},q_2) \in T$, then for all states $p\in P$, we have $((q_1,p),(v_i^{(j)},\epsilon),(q_2,p))\in \syncT$.
\item If $(p_1,v_i^{(j)},p_2) \in T'$, then for all states $q\in Q,((q,p_1)$, we have $(\epsilon,v_i^{(j)}),(q,p_2))\in \syncT$.
\item If $(q_1,v_i^{(j)},q_2) \in T$ and $(p_1,v_{i'}^{(j')},p_2) \in T'$, then we have $((q_1,p_1),(v_i^{(j)},v_{i'}^{(j')}),(q_2,p_2))\in \syncT$.
\end{itemize}	
The first two cases correspond to the situation when the character variable $v_i^{(j)}$ is assigned $\epsilon$. In such cases, only one automaton changes its state.

For example, in the product automaton $A_{xy=yx}$ corresponds to $xy=yx$, we have the following transitions
\begin{itemize}
	\item $((q_0,p_0), (v_0^{(0)},\epsilon),(q_1,p_0))$, because $(q_0,v_0^{(0)},q_1)$ is a transition of $A_{xy}$.
	\item $((q_0,p_0), (\epsilon,\epsilon),(q_0,q_0))$, because $(p_0,\epsilon,q_0)$ is a transition of $A_{yx}$.
	\item $((q_0,p_0), (v_0^{(0)},v_2^{(1)}),(q_1,q_1))$, because $(q_0,v_0^{(0)},q_1)$ is a transition of $A_{xy}$ and $(p_0,v_2^{(1)},p_1)$ is a transition of $A_{yx}$.
\end{itemize}

Recall that for flat automata, the number of occurrences of each symbol uniquely characterizes an accepting string (Section~\ref{section:sfa}) and for any finite automaton we can construct a Presburger formula characterizing its Parikh image (Section~\ref{section:preliminary}). For a product automaton $A$ computed from the previous step, we compute a Presburger formula $\phi(A)$ over the set of variables $\{\#{(v_i^{(j)},v_{i'}^{(j')})}\mid (v_i^{(j)},v_{i'}^{(j')}) \in \cvarone \times \cvartwo\}$ characterizing the Parikh image of $A$. We use $\#(v_i)$ and $\#(v_i^{(j)})$ to denote the number of occurrences of $v_i$ and $v_i^{(j)}$, respectively. The following formulas establish the relation of the number of occurrences of symbols between the PFAs and the product automaton.
\begin{enumerate}
	\item for all $v_i^{(j)} \in \cvarone$, $\#(v_i^{(j)}) = \sum_{v \in {\cvartwo \cup \{\epsilon\}}} \#{(v_i^{j},v)}$   
	\item for all $v_i^{(j)} \in \cvartwo$, $\#(v_i^{(j)}) = \sum_{v \in {\cvarone \cup \{\epsilon\}}} \#{(v,v_i^{j})}$ 
\end{enumerate}

Then we add the following linear constraints to enforce  condition 1. and 2. required for the pair of symbolic string $(w_n, w_m)$ and $I$, i.e., $I(w_n) = I(w_m)$ and $I$ assign the same value to all versions of the same variable (we use $-1$ as the value of $\epsilon$). 
\begin{enumerate}
	\item for all $v_i^{(j)}\in \cvarone$ and $v_{i'}^{(j')}\in \cvartwo$, $\#{(v_i^{(j)},v_{i'}^{(j')})}>0 \rightarrow (v_i=v_{i'})$,\lh{typo?} 
	\item for all $v_i^{(j)}\in \cvarone$, $\#{(v_i^{(j)},\epsilon)}>0 \rightarrow (v_i=\epsilon)$, and
	\item for all $v_{i'}^{(j')}\in \cvartwo$,$\#{(\epsilon,v_{i'}^{(j')})}>0 \rightarrow (v_{i'}=\epsilon)$.
\end{enumerate}
We then add the linear constraints $\#(v_i) = \#(v_i^{(j)})$, for all $v_i\in \cvar$ and all different version numbers $j$ for $v_i$, to enforce condition 3, which says different versions of the same variable should occurs equally often in $w_n\cdot w_m$. 

From the model $M$ of the linear constraints, we can obtain $w_n$, $w_m$, and $I$. The interpretation $I$ is defined as $I(v)=M(v)$ for all $v\in (\cvarone \cup \cvartwo)$. The symbolic words $w_n$ and $w_m$ can be obtained by traverse the PFAs following the number of occurrences of each character variables.
More specifically, assume that the PFA $S_n$ is the one in Figure~\ref{fig:sfa_def}, then $$w_n = (v_0^0v_0^1v_0^2v_0^3)^{\#(v_0^0)}v_0(v_1^0v_1^1v_1^2)^{\#(v_1^0)}v_1\ldots(v_m^0v_m^1v_m^2v_m^3)^{\#(v_m^0)}$$
Note that $\#(v_0^0)=\#(v_0^1)=\#(v_0^2)=\#(v_0^3)$, so we just use $\#(v_0^0)$ to denote the number of times of first loop traversal. One can construct $w_m$ in a similar way. Using the same approach, one can derive the assignment to variables in $\vars$ using the corresponding count and values of variables in $\cvar$.





\todo{Maybe talk about the heuristic that we merge the list elements into one}

}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Handling String-Integer Conversion} \label{section:s2i}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Assume that the constraint we take from $\Phi_I$ is a string-number conversion constraint  $\phi_s \defeq n=\sti{x}$. We will discuss how to make the corresponding linear formulas in this section.

Let us begin the discussion with a simple example, assume that we use the PFA in Figure~\ref{fig:sfa} (a) to restrict the domain of $x$. Then we know that when $0\leq v_0,v_1 \leq 9$, then $n$ is a positive integer value, and otherwise $n =-1$. So we should first add the constraint $ ((0\leq v_0\leq 9) \wedge (0\leq v_1\leq 9)) \vee n=-1 $.

For the case that $n$ is a positive integer, the value of $n$ can be characterized by a constraint $n= (v_0\times 10+ v_1) \times (1+100 +100^2 + \ldots 100 ^{\#(v_0)-1})=  (v_0\times 10+ v_1) \times \frac{100^{\#(v_0)}-1}{100-1}$. 
The constraint uses $\#(v_0)$ to capture the total number of loop traversal.
Notice that the constraint above contains an exponential component $\frac{100^{\#(v_0)}}{100-1}$. To solve the satisfiability of this formula, one need to solve an exponential constraint. 

Let us have a look at another example. If we restrict the domain of $x$ to the PFA in Figure~\ref{fig:sfa} (c), for the case when $n$ is positive, we have the relation $n= (v_0^{(0)}\times 10+ v_1^{(0)}) \times (1+100 +100^2 + \ldots 100 ^{\#(v_0^{(0)})-1})\times 100^{\#(v_2^{(0)})}+(v_2^{(0)}\times 10+ v_3^{(0)}) \times (1+100 +100^2 + \ldots 100 ^{\#(v_2^{(0)})-1}) =  (v_0^{(0)}\times 10+ v_1^{(0)}) \times \frac{100^{\#(v_0^{(0)})}-1}{100-1}\times 100^{\#(v_2^{(0)})} + (v_2^{(0)}\times 10+ v_3^{(0)}) \times \frac{100^{\#(v_2^{(0)})}-1}{100-1}$. Observe that the formula has two exponential components $\frac{100^{\#(v_0^{(0)})}\times 100^{\#(v_2^{(0)})} }{100-1}$ and $\frac{100^{\#(v_2^{(0)})} }{100-1}$.

It is not difficult to observe that, for the case of an arbitrary PFA of $m$ loops, the formula to define $n$ contains $m$ exponential components, one for each loop.
To the best of our knowledge, the satisfiability problem of integer constraints with a mix of polynomials and exponentials is still open. As said in the introduction, the problem is difficult even for the case that variables are real numbers. For example, the algorithm in~\cite{kincaid2019closed} involves a quantifier elimination procedure, which is double-exponential to the length of the input formula and hence cannot handle large instances. So we do not expect that this constraint can be solved efficiently.

\paragraph{PFA that allows efficient string-number conversion: } In the previous discussion, we know that it is unlikely to use arbitrary PFA and gain efficient solving procedure, due to the requirement to solve exponential integer constraints. The problem is that each loop in the PFA creates an exponential component. An immediate idea would be that maybe we can restrict the variable to some specific PFA that allow more efficient constraint solving. At the same time, we want to keep some good property, i.e., the search space covers all integers with at most $m$-digits.

Our first attempt is a PFA with no loop, i.e., a straight line structure. The corresponding integer constraint does not have exponential components. However, it does not ensure the property that all numbers with at most $m$-digits are covered. Consider the example $\sti{x}=10 \wedge |x|=5$. The number $10$ has only $2$-digits, at the first glance, a straight-line PFA with two transitions, i.e., the PFA \scalebox{0.5}{\tikzset{state/.style={circle,draw=blue!50,fill=blue!20,
			thick,inner sep=0pt,minimum size=6mm}, initial text=$ $}
	\begin{tikzpicture} 
	\node[state,initial] (q0)  {$q_0$};
	\node[state] (q1) [right = 1cm of q0] {$q_1$};
	\node[state,accepting] (q2) [right = 1cm of q1] {$q_2$};
	
	\draw[->] (q0) edge node [below]{$v_1$} (q1) ;
	\draw[->] (q1) edge node [below]{$v_2$} (q2) ;
	\end{tikzpicture}} should be sufficient for the domain restriction of $x$. If we do so, we will conclude that the formula is unsatisfiable, because the length of $x$ cannot be $5$  under this domain restriction.

However, the formula is satisfiable when $x=``00010"$. Observe that $\sti{``00010"}=10$. The key is that even for a bounded integer, the corresponding string can be of unbounded length with arbitrarily many `$0$' characters at the front. In order to handle all number with at most $m$ digits, we propose to restrict the domain of $x$ to a PFA in Figure~\ref{fig:sfa_its}.  The PFA has a self-loop transition labeled $v_0$ at $q_0$ and we add a constraint $v_0=0$ to $\Phi_O$ for such PFA. With this transition, we can ensure that the under-approximation handles all numbers with at most $m$ digits. Although this PFA still has a loop, but it will not create any exponential component because the loop only represents a sequence of `0' that occurs in the prefix of $x$. It will not affect the integer value of $n=\sti{x}$.

\begin{figure}
	\tikzset{state/.style={circle,draw=blue!50,fill=blue!20,
			thick,inner sep=0pt,minimum size=6mm}, initial text=$ $}
	\begin{tikzpicture} 
	\node[state,initial] (q0)  {$q_0$};
	\node[state] (q1) [right = 1cm of q0] {$q_1$};
	\node (q2) [right = 0.8cm of q1]{};
	\node (q3) [right = 1cm of q2]{};
	\node[state,accepting] (qm) [right = 1cm of q3] {$q_m$};
	
	\draw[->] (q0) edge node [below]{$v_1$} (q1) ;
	\draw[->] (q1) edge node [below]{$v_2$} (q2) ;
	\draw[dotted] (q2) edge (q3) ;
	\draw[->] (q3) edge node [below]{$v_m$} (qm) ;
	\path (q0) edge [loop above] node {$v_0$} (q0);
	\end{tikzpicture} 
	
	\caption{An example of a symbolic flat automaton}
	\label{fig:sfa_its}
\end{figure}

Such PFA handles bounded integers (e.g., 10-digits or 64-bits) precisely and under-approximate the possible values of unbounded integers. It works very efficiently because we just need to use linear constraints to characterize the relation between $x$ and $n$. 
Remember that the character variables can be assigned $\epsilon$. In order to simplify the construction, we an encoding to shift all the $\epsilon$-transitions to the least significant digits, i.e., if $v_j = \epsilon = -1$ then $v_k = -1$ for all $k\in [j+1,m]$.  To explain this encoding, we first define two macro function:

$$\begin{array}{rl}
\mathsf{epsilonAfter(k)}\defeq& (0\leq v_0,\ldots, v_k\leq 9) \wedge\\
&v_{k+1}=\ldots =v_m = -1\\
\mathsf{toNumber(k)}\defeq& (n = v_0\times 10^{k} + v_1\times 10^{k-1} + \ldots + v_{k})
\end{array}
$$

The function $\mathsf{epsilonAfter(k)}$ forces the first $k$ variables to be assigned some number and those after $k$ be assigned $\epsilon$. Recall that we use $-1$ to represent $\epsilon$. The function $\mathsf{toNumber(k)}$ converts the first $k$ variables to the corresponding number in $n$.
Then we can specify the relation between $n$ and the character variables as follows:
$$\phi_n\defeq (n=-1 \vee \bigvee_{k\in [0,m]} (\mathsf{epsAfter(k)} \wedge \mathsf{toNumber(k)} ) )$$
It says either $x$ is not a number and so $n=-1$ or the first $k$ variables represent the value of $n$, for some $k\in [0,m]$. 

\yfc{add a Lemma for correctness}


\hide{The length of $x$ can be specified by the following formula.

$\begin{array}{ccc}
	(|x|&=& \#(v_0)+1 \wedge 0\leq v_1 \leq 9 \wedge v_2 = -1)\vee \\
	(|x|&=& \#(v_0)+2 \wedge 0\leq v_2 \leq 9 \wedge v_3 = -1)\vee \\
	& &\ldots\\
	(|x|&=& \#(v_0)+(m-1) \wedge 0\leq v_{m-1} \leq 9 \wedge v_m = -1)\vee\\
	(|x|&=& \#(v_0)+m \wedge 0\leq v_m \leq 9 )
\end{array}$}


% \section{Evaluation}
%  \label{section:evaluation}
% \todo{copy a few tables from our test site to here}

\section{Implementation}\label{section:implementation}
\input{evaluation}
\newpage
\bibliographystyle{ACM-Reference-Format}
\bibliography{refs}

\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
