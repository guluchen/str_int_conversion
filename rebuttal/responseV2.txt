We thank the reviewers for their detailed and constructive feedback and suggestions. Below, we address the main points from the reviews:
	 
1. Comparison with the FA-based solvers. More insight into why the PFA-based approach is better.(ReviewerB,C)

  * PFA is labeled by variables, while FA is by concrete symbols. If Unicode (>60000 symbols) is used, we need >60000 transitions to connect two states of an FA, but only one for PFA. 

  * FA-based approach can, in theory, be turned to support string-number conversion, but would be more expensive than using PFA. PFA is labeled by integer variables that can be used directly in the string-number translation. In FA, this would require multiple if-then-else statements (e.g., saying that if a transition labeled '0' is taken, then the corresponding number is 0), which introduces a significant amount of additional predicates that the DPLL engine needs to decide their value. 

  * In practice, the string-number conversion is not implemented in the existing FA-based tool Trau. The implementation of Trau is done by **substituting** the string solver component of Z3 with a completely new that does not support string-number conversion constraints. Running the string-number conversion benchmarks on Trau will get incorrect answers. We have compared with the latest version of Trau on basic string constraints, and, in general, Z3-PFA is better. 

2. Comparison with DPLL-based solvers.(ReviewerA)

  * To the best of our knowledge, Z3 and CVC4 are the best DPLL(T)-based string solvers that are still well-maintained. 
Most SAT-based string solvers such as Hampi and Kazula are no longer maintained.

3. Provide more support to your claim that string-number conversion is difficult for existing solvers.(ReviewerB,C)

  * We will (1) refer to the fact that the extension of existing FA based techniques boils down to solving the satisfiability problem of integer constraints with a mix of polynomials and exponentials, which is still open (see Section 8), and (2) refer to our experimental results.  
	 
4. How significant it is to introduce the string-number conversion?(ReviewerB)

  * JavaScript makes far more use of such conversions than other languages to which SMT solvers have traditionally been applied. Every access to the state of any modeled object relies on it since array indices get turned into strings (see discussion starting at line 150 of the submission). Since JavaScript is pervasive, such checking is very significant.
	  
5. How to decide the structure of PFA used by the solvers?(ReviewerB,D)	 

  * The structure is given by the main loop of the algorithm and is implementation-dependent. We describe the PFA selection strategy of Z3-PFA in the 2nd paragraph of Section 9. The process is fully automated.
	 
6. Break down the X results in the experiments further. Did you find uncovered bugs in some of the solvers? If yes, why does it happen?(ReviewerA,C) 

  * We will update it in the next version. We do find some cases where existing solvers provide incorrect answers. There might be several reasons that the answer is wrong. We checked the source code of Z3. One reason we found is that when both n and x in the constraint n=toNum(x) are variables, it over-approximates the toNum(x) function with an uninterpreted function, with additional axioms like toStr(toNum(x))=x. Sometimes Z3 gives a wrong answer because of this over-approximation.

7. Converted the function *checkLuhn* into C, and find out KLEE works fine.(ReviewerC)

  * Converting *checkLuhn* into C code will alter its semantics substantially. The function makes use of array accesses with charAt() calls (lines 4, 8, 12) and, which, in JavaScript, require string-integer conversions to handle since the array state must be indexed with *strings*.
	 
8. The selection of timeout for the evaluation.(ReviewerA,C)	 

  * We need to handle the time required for artifact evaluation. Table 1 and 2 have many instances so that a 120s timeout would require days to reproduce the result. CheckLuhn has only a few instances, so a higher time budget is still possible. In our evaluation, using different timeout will not alter the overall trend much.
	 
9. Compare with PASS in your evaluation.(ReviewerC)
	 
  * We have contacted the authors of PASS, and they say the code is no longer maintained. We will add it to the related work.

10. How you construct a PFA that is aware of the domain of a constraint?(ReviewerC)

  * We assume all numbers are octal following the SMTLIB2 standard.

11. Each numeric PFA can only cover one number?(ReviewerC)

  * PFA transitions are labeled by variables, c.f., Fig 3. Each assignment of the variables corresponds to a number.