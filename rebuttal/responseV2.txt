We thank the reviewers for their detailed and constructive feedback and suggestions. First, we address general issues raised by several reviewers. Then, we answer the particular comments of each reviewer.


### General Comments:



* **Comparison with FA-based solvers. More insight into why the PFA-based approach is better.(ReviewerB,C)**

> In theory, a straightforward  extension of existing  FA (even PFA)  techniques to support string-number conversion can lead to solving the satisfiability problem of integer constraints with a mix of polynomials and exponentials, which is still open (see Section 8). One can adapt the efficient string-number conversion techniques (described in Section 8) to FA; however, this would be more expensive than using PFA. PFA is labeled by integer variables that can be used directly in the string-number translation. In the case of FA, transitions are labeled by concrete symbols. If Unicode (>60000 symbols) is used, we need >60000 transitions to connect two states of an FA, but only one for PFA.
More precisely, this would require multiple if-then-else statements (e.g., saying that if a transition labeled '0' is taken, then the corresponding number is 0), which introduces a significant amount of additional predicates that the DPLL engine needs to decide their value. We will make this more clear in the next version of the paper.

> In practice, the string-number conversion is not supported by the FA-based tool Trau. The implementation of Trau is done by **substituting** the string solver component of Z3 with a completely new that does not support string-number conversion constraints. Running the string-number conversion benchmarks using Trau will result in incorrect answers. We have compared with the latest version of Trau on basic string constraints, and, in general, Z3-PFA is better. We will present these results in the experimental section.


* **Provide more support to your claim that string-number conversion is difficult for existing solvers.(ReviewerB,C)**

> We will (1) refer to the fact that the extension of existing FA based techniques boils down to solving the satisfiability problem of integer constraints with a mix of polynomials and exponentials, which is still open (see Section 8), and (2) refer to our experimental results.  
	 
* **How to decide the structure of PFA used by the solvers?(ReviewerB,D)**	 

> The structure of PFA is decided by iteratively by the main loop of our algorithm. We describe the PFA selection strategy of Z3-PFA in the 2nd paragraph of Section 9. The process is fully automated.

* **Break down the X results in the experiments further. Did you find uncovered bugs in some of the solvers? If yes, why does it happen?(ReviewerA,C)**

>  We will update it in the next version. We do find some cases where existing solvers provide incorrect answers. There might be several reasons why  the answer is wrong. We checked the source code of Z3. One reason we found is that when both n and x in the constraint n=toNum(x) are variables, it over-approximates the toNum(x) function with an uninterpreted function, with additional axioms like toStr(toNum(x))=x. Sometimes Z3 gives a wrong answer because of this over-approximation. We usually report directly uncovered bugs to the authors of the tool.

### Reviewer A:

* **Comparison with DPLL-based solvers**

> To the best of our knowledge, Z3 and CVC4 are DPLL(T)-based string solvers that are well-known and still well-maintained. 
Most SAT-based string solvers such as Hampi and Kazula are no longer maintained.


### Reviewer B:

* **How significant it is to introduce the string-number conversion?**

  * JavaScript makes far more use of such conversions than other languages to which SMT solvers have traditionally been applied. Every access to the state of any modeled object relies on it since array indices get turned into strings (see discussion starting at line 150 of the submission). Since JavaScript is pervasive, such checking is very significant.
	  

### Reviewer C:
	 
* **Converted the function *checkLuhn* into C, and find out KLEE works fine**

> Converting *checkLuhn* into C code will alter its semantics substantially. The function makes use of array accesses with charAt() calls (lines 4, 8, 12) and, which, in JavaScript, require string-integer conversions to handle since the array state must be indexed with *strings*.
	 
* **Compare with PASS in your evaluation**
	 
> We have contacted the authors of PASS, and they say the code is no longer maintained. We will add it to the related work.

* **How you construct a PFA that is aware of the domain of a constraint?**

> We assume all numbers are octal following the SMTLIB2 standard.

* **Each numeric PFA can only cover one number?**

> PFA transitions are labeled by variables, c.f., Fig 3. Each assignment of the variables corresponds to a number.


### Reviewer D:

* **Wasting effort when considering larger PFAs iteratively.**

> we are considering this as a future work.

